#ifndef AKIRA_IO_BITMAP_FONT_HPP
#define AKIRA_IO_BITMAP_FONT_HPP

#include <cstdint>

// Simple 8x8 pixel bitmap font for stats overlay
// Characters 32-126 (95 printable ASCII characters)
// Each character is 8 bytes (8 pixels tall, 8 pixels wide, 1 bit per pixel)

namespace BitmapFont
{
    constexpr int CHAR_WIDTH = 8;
    constexpr int CHAR_HEIGHT = 8;
    constexpr int FIRST_CHAR = 32;   // Space
    constexpr int LAST_CHAR = 126;   // Tilde
    constexpr int NUM_CHARS = LAST_CHAR - FIRST_CHAR + 1;  // 95 characters

    // Font atlas layout: 16 chars per row, 6 rows = 96 cells (one extra)
    constexpr int ATLAS_COLS = 16;
    constexpr int ATLAS_ROWS = 6;
    constexpr int ATLAS_WIDTH = ATLAS_COLS * CHAR_WIDTH;   // 128 pixels
    constexpr int ATLAS_HEIGHT = ATLAS_ROWS * CHAR_HEIGHT; // 48 pixels

    // 8x8 font data - each byte is one row, MSB is leftmost pixel
    // clang-format off
    constexpr uint8_t FONT_DATA[NUM_CHARS][CHAR_HEIGHT] = {
        // 32: Space
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        // 33: !
        {0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00},
        // 34: "
        {0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00},
        // 35: #
        {0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00},
        // 36: $
        {0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00},
        // 37: %
        {0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00},
        // 38: &
        {0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00},
        // 39: '
        {0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00},
        // 40: (
        {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00},
        // 41: )
        {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00},
        // 42: *
        {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},
        // 43: +
        {0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00},
        // 44: ,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30},
        // 45: -
        {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00},
        // 46: .
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00},
        // 47: /
        {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00},
        // 48: 0
        {0x7C, 0xC6, 0xCE, 0xD6, 0xE6, 0xC6, 0x7C, 0x00},
        // 49: 1
        {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00},
        // 50: 2
        {0x7C, 0xC6, 0x06, 0x1C, 0x30, 0x66, 0xFE, 0x00},
        // 51: 3
        {0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00},
        // 52: 4
        {0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00},
        // 53: 5
        {0xFE, 0xC0, 0xC0, 0xFC, 0x06, 0xC6, 0x7C, 0x00},
        // 54: 6
        {0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00},
        // 55: 7
        {0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00},
        // 56: 8
        {0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00},
        // 57: 9
        {0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00},
        // 58: :
        {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00},
        // 59: ;
        {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30},
        // 60: <
        {0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},
        // 61: =
        {0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00},
        // 62: >
        {0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00},
        // 63: ?
        {0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00},
        // 64: @
        {0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00},
        // 65: A
        {0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00},
        // 66: B
        {0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00},
        // 67: C
        {0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00},
        // 68: D
        {0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00},
        // 69: E
        {0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00},
        // 70: F
        {0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00},
        // 71: G
        {0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3A, 0x00},
        // 72: H
        {0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00},
        // 73: I
        {0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00},
        // 74: J
        {0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00},
        // 75: K
        {0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00},
        // 76: L
        {0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00},
        // 77: M
        {0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00},
        // 78: N
        {0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00},
        // 79: O
        {0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00},
        // 80: P
        {0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00},
        // 81: Q
        {0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xCE, 0x7C, 0x0E},
        // 82: R
        {0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00},
        // 83: S
        {0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00},
        // 84: T
        {0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x3C, 0x00},
        // 85: U
        {0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00},
        // 86: V
        {0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00},
        // 87: W
        {0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00},
        // 88: X
        {0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00},
        // 89: Y
        {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00},
        // 90: Z
        {0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00},
        // 91: [
        {0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00},
        // 92: backslash
        {0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00},
        // 93: ]
        {0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00},
        // 94: ^
        {0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00},
        // 95: _
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
        // 96: `
        {0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00},
        // 97: a
        {0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00},
        // 98: b
        {0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00},
        // 99: c
        {0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00},
        // 100: d
        {0x1C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00},
        // 101: e
        {0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00},
        // 102: f
        {0x1C, 0x36, 0x30, 0x78, 0x30, 0x30, 0x78, 0x00},
        // 103: g
        {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x78},
        // 104: h
        {0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00},
        // 105: i
        {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00},
        // 106: j
        {0x06, 0x00, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C},
        // 107: k
        {0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00},
        // 108: l
        {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00},
        // 109: m
        {0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0x00},
        // 110: n
        {0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x00},
        // 111: o
        {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00},
        // 112: p
        {0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0},
        // 113: q
        {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E},
        // 114: r
        {0x00, 0x00, 0xDC, 0x76, 0x60, 0x60, 0xF0, 0x00},
        // 115: s
        {0x00, 0x00, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x00},
        // 116: t
        {0x30, 0x30, 0xFC, 0x30, 0x30, 0x36, 0x1C, 0x00},
        // 117: u
        {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00},
        // 118: v
        {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00},
        // 119: w
        {0x00, 0x00, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00},
        // 120: x
        {0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00},
        // 121: y
        {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x7C},
        // 122: z
        {0x00, 0x00, 0xFE, 0x8C, 0x18, 0x32, 0xFE, 0x00},
        // 123: {
        {0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00},
        // 124: |
        {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},
        // 125: }
        {0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00},
        // 126: ~
        {0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    };
    // clang-format on

    // Generate font atlas texture data (single channel, 8-bit)
    // Returns a dynamically allocated array that must be freed with delete[]
    inline uint8_t* generateAtlasTexture()
    {
        uint8_t* atlas = new uint8_t[ATLAS_WIDTH * ATLAS_HEIGHT];

        // Initialize to transparent (0)
        for (int i = 0; i < ATLAS_WIDTH * ATLAS_HEIGHT; i++)
        {
            atlas[i] = 0;
        }

        // Render each character to the atlas
        for (int charIdx = 0; charIdx < NUM_CHARS; charIdx++)
        {
            int col = charIdx % ATLAS_COLS;
            int row = charIdx / ATLAS_COLS;

            int baseX = col * CHAR_WIDTH;
            int baseY = row * CHAR_HEIGHT;

            for (int y = 0; y < CHAR_HEIGHT; y++)
            {
                uint8_t rowData = FONT_DATA[charIdx][y];
                for (int x = 0; x < CHAR_WIDTH; x++)
                {
                    // MSB is leftmost pixel
                    if (rowData & (0x80 >> x))
                    {
                        int atlasX = baseX + x;
                        int atlasY = baseY + y;
                        atlas[atlasY * ATLAS_WIDTH + atlasX] = 255;
                    }
                }
            }
        }

        return atlas;
    }

    // Get UV coordinates for a character (returns u1, v1, u2, v2)
    inline void getCharUV(char c, float& u1, float& v1, float& u2, float& v2)
    {
        int charIdx = static_cast<unsigned char>(c) - FIRST_CHAR;
        if (charIdx < 0 || charIdx >= NUM_CHARS)
        {
            charIdx = 0;  // Default to space for unknown characters
        }

        int col = charIdx % ATLAS_COLS;
        int row = charIdx / ATLAS_COLS;

        u1 = static_cast<float>(col * CHAR_WIDTH) / ATLAS_WIDTH;
        v1 = static_cast<float>(row * CHAR_HEIGHT) / ATLAS_HEIGHT;
        u2 = static_cast<float>((col + 1) * CHAR_WIDTH) / ATLAS_WIDTH;
        v2 = static_cast<float>((row + 1) * CHAR_HEIGHT) / ATLAS_HEIGHT;
    }

}  // namespace BitmapFont

#endif  // AKIRA_IO_BITMAP_FONT_HPP
